<!DOCTYPE html>
<html lang="zh-CN">
<head>
  	<meta charset="UTF-8">
	<title>JavaScript Funlibs</title>
  	<link rel="icon" href="../img/favicon.jpg">
	<!-- 已使用prism.js的tomorrow night主题高亮代码块__2021/03/27 <style type="text/css">
		pre {
			background-color: rgb(52, 61, 70);
			color: rgb(216, 222, 233);

			font-family: monospace, Helvetica, sans-serif;
			font-size: 18px;
			font-weight: lighter;

			overflow: auto;
			line-height: 1.2;
			tab-size: 4;
			/*white-space: pre-wrap;*/
		}

		code .keyword {
			color: rgb(162, 149, 198);
		}
		  
		code .function {
		    color: rgb(96, 180, 167);
		}

		code .methods {
			color: rgb(96, 153, 188);
		}

		code .variable {
			color: rgb(249,174,87);
		}

		code .operator {
			color: rgb(249,123,87);
		}

		code .boolean {
			color: rgb(236,91,87);
		}

	</style> -->

	<link rel="stylesheet" type="text/css" href="../css/js_funlibs.css">
	<link rel="stylesheet" type="text/css" href="../css/modules/prism.css">

</head>
<body>
	<!-- 2021-03-24 updated -->

	<h1>JavaScript Funlibs--记录常用函数（方法）</h1>
	<hr>
	<h2 id="索引">索引</h2>
	<ul>
		<li><a href="#1. 输出num范围内的素数（质数）">1. 输出num范围内的素数（质数）</a></li>
		<li><a href="#2. 判断对象是否为空">2. 判断对象是否为空</a></li>
		<li><a href="#3. 递归返回范围内数组">3. 递归返回范围内数组</a></li>
		<li><a href="#4. 生成范围内随机数（包含起止点）">4. 生成范围内随机数（包含起止点）</a></li>
		<li><a href="#5. 找出所有项的和最大的 arr 数组的连续子数组">5. 找出所有项的和最大的 arr 数组的连续子数组</a></li>
		<li><a href="#6. 随机排列数组">6. 随机排列数组</a></li>
		<li><a href="#7. 数组去重">7. 数组去重</a></li>
		<li><a href="#8. 数组去重--使用Set集合数据类型">8. 数组去重--使用Set集合数据类型</a></li>
		<li><a href="#9. 使用Symbol.iteraor迭代对象">9. 使用Symbol.iteraor迭代对象</a></li><li><a href="#10. 遍历对象并修改值">10. 遍历对象并修改值</a></li>
		<li><a href="#11. 许多天之前是哪个月几号？">11. 许多天之前是哪个月几号？</a></li>
		<li><a href="#12. 生成第n个斐波那契数的3种方法">12. 生成第n个斐波那契数的3种方法</a></li>
		<li><a href="#13. 使用 spread 语法进行数组/对象的浅拷贝">13. 使用 spread 语法进行数组/对象的浅拷贝</a></li>

	</ul>
	<hr>
	<h2 id="1. 输出num范围内的素数（质数）">1. 输出num范围内的素数（质数）</h2>
	<pre><code class="language-javascript">
	// 输出num范围内的素数（质数）
	<span class="keyword">function</span> <span class="function">showPrimes</span>(<span class="variable">num</span>) {

		<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="operator">=</span> <span class="variable">2</span>; i <span class="operator"><</span> num; i<span class="operator">++</span>) {
			<span class="keyword">if</span> ( <span class="methods">isPrime</span>(i) ) {
				<span class="methods">console</span>.<span class="methods">log</span>(i);
			}
		}

	}

	<span class="keyword">function</span> <span class="function">isPrime</span>(<span class="variable">num</span>) {
	    
		<span class="keyword">for</span> (<span class="keyword">let</span> j <span class="operator">=</span> <span class="variable">2</span>; j <span class="operator"><</span> num; j<span class="operator">++</span>) {
			<span class="keyword">if</span> (num <span class="operator">%</span> j <span class="operator">===</span> <span class="variable">0</span>) {
				<span class="keyword">return</span> <span class="boolean">false</span>;
			}
		}

		<span class="keyword">return</span> <span class="boolean">true</span>;
	}

	<span class="methods">showPrime</span>(<span class="variable">10</span>); // 2,3,5,7
	</code></pre>

	<h2 id="2. 判断对象是否为空">2.判断对象是否为空</h2>
	<pre><code class="language-javascript">
	// 判断对象是否为空
	<span class="keyword">function</span> <span class="function">isEmpty</span>(<span class="variable">obj</span>) {
		
		<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) {
			<span class="keyword">return</span> <span class="boolean">false</span>;
		}

		<span class="keyword">return</span> <span class="boolean">true</span>;
	}
	</code></pre>

	<h2 id="3. 递归返回范围内数组">3.递归返回范围内数组</h2>
	<pre><code class="language-javascript">
	// 递归返回正序范围内数组
	<span class="keyword">function</span> <span class="function">rangeOfNumbers</span>(<span class="variable">startNum</span>, <span class="variable">endNum</span>) {

		<span class="keyword">if</span> (startNum <span class="operator">===</span> endNum) <span class="keyword">return</span> [startNum];
		<span class="keyword">else</span> <span class="keyword">if</span> (startNum <span class="operator"><</span> endNum) {
			endNum<span class="operator">--</span>;
			<span class="keyword">return</span> ( <span class="methods">rangeOfNumbers</span>(startNum, endNum) ).<span class="methods">concate</span>(endNum <span class="operator">+</span> <span class="variable">1</span>);
		}
	}

	<span class="methods">rangeOfNumbers</span>(<span class="variable">4</span>,<span class="variable">7</span>); // [4,5,6,7]

	// 递归返回逆序范围内数组
	<span class="keyword">function</span> <span class="function">rangeOfNumbers</span>(<span class="variable">startNum</span>, <span class="variable">endNum</span>) {

		<span class="keyword">if</span> (startNum <span class="operator">===</span> endNum) <span class="keyword">return</span> [endNum];
		<span class="keyword">else</span> <span class="keyword">if</span> (startNum <span class="operator"><</span> endNum) {
			startNum<span class="operator">++</span>;
			<span class="keyword">return</span> ( <span class="methods">rangeOfNumbers</span>(startNum, endNum) ).<span class="methods">concate</span>(startNum <span class="operator">-</span> <span class="variable">1</span>);
		}
	}

	<span class="methods">rangeOfNumbers</span>(<span class="variable">4</span>,<span class="variable">7</span>); // [7,6,5,4]
	</code></pre>

	<h3>To Do List</h3>
	<ol>
		<li>丰富Funlibs函数库</li>
		<li>添加CSS,使&lt;pre&gt;&lt;code&gt;标签中的代码有颜色</li>
		<li>...</li>
	</ol>
	<label>更新于<input type="date" value="2021-03-24" disabled>__chinrunja</label>
	<hr>

	<!-- 2021-03-25 updated -->

	<h2 id="4. 生成范围内随机数（包含起止点）">4. 生成范围内随机数（包含起止点）</h2>
	<pre><code class="language-javascript">
	// 生成范围内随机数（包含起止点）
	<span class="keyword">function</span> <span class="function">randomInteger</span>(<span class="variable">min</span>, <span class="variable">max</span>) {
    	<span class="keyword">return</span> <span class="keyword">Math</span>.<span class="methods">floor</span>(<span class="keyword">Math</span>.<span class="methods">random</span>() <span class="operator">*</span> (max <span class="operator">-</span> min <span class="operator">+</span> <span class="variable">1</span>)) <span class="operator">+</span> min;
	}

	<span class="methods">randomInteger</span>(<span class="variable">1</span>, <span class="variable">5</span>);
	</code></pre>

	<h3>Complaints</h3>
	<ol>
		<li>太菜了，搜了&lt;pre&gt;&lt;code&gt;样式化，搞不定，只能徒手加CSS和一堆的&lt;span&gt;标签...</li>
		<li>还是学个js模块来完成code颜色样式化吧</li>
		<li>今天更新内容有点少，时间都花在替换&lt;span&gt;标签上了...</li>
		<li>对了，配色用的是sublime text3的Mariana主题，取色器取的颜色</li>
	</ol>
	<label>更新于<input type="date" value="2021-03-25" disabled>__chinrunja</label>
	<hr>

	<!-- 2021-03-26 updated -->

	<h2 id="5. 找出所有项的和最大的 arr 数组的连续子数组">5. 找出所有项的和最大的 arr 数组的连续子数组</h2>
	<p>如果所有项都是负数，那就一个项也不取（子数组是空的），返回 0。</p>
	<pre><code class="language-javascript">
	// 复杂度为O(n<sup>2</sup>)
	function getMaxSubSum(arr) {
  		let maxSum = 0; // 如果没有取到任何元素，就返回 0

  		for (let i = 0; i < arr.length; i++) {
    		let sumFixedStart = 0;
    		for (let j = i; j < arr.length; j++) {
      			sumFixedStart += arr[j];
      			maxSum = Math.max(maxSum, sumFixedStart);
    		}
  		}

  		return maxSum;
	}

	console.log( getMaxSubSum([-1, 2, 3, -9]) ); // 5
	console.log( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
	console.log( getMaxSubSum([-2, -1, 1, 2]) ); // 3
	console.log( getMaxSubSum([1, 2, 3]) ); // 6
	console.log( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100

	// 复杂度改进为O(n)
	// 遍历数组，将当前局部元素的和保存在变量 s 中。如果 s 在某一点变成负数了，就重新分配 s=0。所有 s 中的最大值就是答案。
	function getMaxSubSum(arr) {
  		let maxSum = 0;
  		let partialSum = 0;

  		for (let item of arr) { // arr 中的每个 item
    		partialSum += item; // 将其加到 partialSum
    		maxSum = Math.max(maxSum, partialSum); // 记住最大值
    		if (partialSum < 0) partialSum = 0; // 如果是负数就置为 0
  		}

  		return maxSum;
	}
	</code></pre>
	<p><strong>参考来源<a href="https://zh.javascript.info/array">JAVASCRIPT.INFO</a>的数组任务</strong></p>

	<h2 id="6. 随机排列数组">6. 随机排列数组</h2>
	<p>所有元素顺序应该具有相等的概率。例如，可以将 [1,2,3] 重新排序为 [1,2,3] 或 [1,3,2] 或 [3,1,2] 等，每种情况的概率相等。</p>
	<pre><code class="language-javascript">
	function shuffle(array) {
  	array.sort(() => Math.random() - 0.5);
	}

	let arr = [1, 2, 3];
	shuffle(arr);
	</code></pre>
	<p>这样是可以的，因为 Math.random() - 0.5 是一个可能是正数或负数的随机数，因此排序函数会随机地对数组中的元素进行重新排序</p>
	<p>请考虑下面的代码。它运行 100 万次 shuffle 并计算所有可能结果的出现次数：</p>
	<pre><code class="language-javascript">
	function shuffle(array) {
  		array.sort(() => Math.random() - 0.5);
	}

	// 所有可能排列的出现次数
	let count = {
  		'123': 0,
  		'132': 0,
  		'213': 0,
  		'231': 0,
  		'321': 0,
  		'312': 0
	};

	for (let i = 0; i < 1000000; i++) {
  		let array = [1, 2, 3];
  		shuffle(array);
  		count[array.join('')]++;
	}

	// 显示所有可能排列的出现次数
	for (let key in count) {
  		console.log(`${key}: ${count[key]}`);
	}
	</code></pre>
	<p>使用不同的 JavaScript 引擎运行这个示例代码得到的结果可能会有所不同，这种方法是不可靠的。</p>
	<p>还有其他很好的方法可以完成这项任务。例如，有一个很棒的算法叫作 <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a>（英文维基百科的链接）。其思路是：逆向遍历数组，并将每个元素与其前面的随机的一个元素互换位置：</p>
	<pre><code class="language-javascript">
	function shuffle(array) {
  		for (let i = array.length - 1; i > 0; i--) {
    		let j = Math.floor(Math.random() * (i + 1)); // 从 0 到 i 的随机索引

    		// 交换元素 array[i] 和 array[j]
    		// 使用“解构分配（destructuring assignment）”语法来实现它
    		// 也可以写成：
    		// let t = array[i]; array[i] = array[j]; array[j] = t
    		[array[i], array[j]] = [array[j], array[i]];
  		}
	}
	</code></pre>
	<p>再按上面的测试方法测试100万次，会发现所有排列都以相同的概率出现。</p>
	<p><strong>参考来源<a href="https://zh.javascript.info/array-methods">JAVASCRIPT.INFO</a>的数组方法任务</strong></p>

	<h3>To Do List</h3>
	<ol>
		<li>丰富Funlibs函数库</li>
		<li>学习Prism.js完善&lt;pre&gt;&lt;code&gt;标签</li>
		<li>刚搜了下prism.js用起来好像还挺简单的，明天试试</li>
	</ol>
	<label>更新于<input type="date" value="2021-03-26" disabled>__chinrunja</label>
	<hr>

	<!-- 2021-03-27 updated -->

	<h2 id="7. 数组去重">7. 数组去重</h2>
	<p>去除数组重复的元素。</p>
	<pre><code class="language-javascript">
	// 该方法有待优化
	function unique(arr) {
		let uniqueArr = [];

		for (let item of arr) {
			if (!uniqueArr.includes(item)) {
				uniqueArr.push(item);
			}
		}

		return uniqueArr;
	}
	</code></pre>

	<h3>To Do List</h3>
	<ol>
		<li>丰富Funlibs函数库</li>
		<li>用CSS美化网页</li>
	</ol>
	<label>更新于<input type="date" value="2021-03-27" disabled>__chinrunja</label>
	<hr>

	<!-- 2021-03-28 updated -->

	<h2 id="8. 数组去重--使用Set集合数据类型">8. 数组去重--使用Set集合数据类型</h2>
	<p>去除数组重复的元素,使用 Set 来存储唯一值。</p>
	<pre><code class="language-javascript">
	function unique(arr) {
    	return Array.from(new Set(arr));
	}

 	let values = ["Hare", "Krishna", "Hare", "Krishna", "Krishna", "Krishna", "Hare", "Hare", ":-O"
	];

	unique(values); // [ "Hare", "Krishna", ":-O" ]
	</code></pre>
	<p>参考来源<a href="https://zh.javascript.info/map-set">JAVASCRIPT.INFO</a>的Map and Set（映射和集合）任务</p>

	<h2 id="9. 使用Symbol.iteraor迭代对象">9. 使用Symbol.iteraor迭代对象</h2>
	<p>为了让 range 对象可迭代（也就让 for..of 可以运行）我们需要为对象添加一个名为 Symbol.iterator 的方法（一个专门用于使对象可迭代的内置 symbol）。</p>
	<ol>
		<li>当 for..of 循环启动时，它会调用这个方法（如果没找到，就会报错）。这个方法必须返回一个 迭代器（iterator） —— 一个有 next 方法的对象。</li>
		<li>从此开始，for..of 仅适用于这个被返回的对象。</li>
		<li>当 for..of 循环希望取得下一个数值，它就调用这个对象的 next() 方法。</li>
		<li>next() 方法返回的结果的格式必须是 {done: Boolean, value: any}，当 done=true 时，表示迭代结束，否则 value 是下一个值。</li>
	</ol>
	<pre><code class="language-javascript">
	let range = {
  		from: 1,
  		to: 5
	};

	// 1. for..of 调用首先会调用这个：
	range[Symbol.iterator] = function() {

  		// ……它返回迭代器对象（iterator object）：
  		// 2. 接下来，for..of 仅与此迭代器一起工作，要求它提供下一个值
  		return {
    		current: this.from,
    		last: this.to,

    		// 3. next() 在 for..of 的每一轮循环迭代中被调用
    		next() {
      			// 4. 它将会返回 {done:.., value :...} 格式的对象
      			if (this.current <= this.last) {
        			return { done: false, value: this.current++ };
      			} else {
        		return { done: true };
      			}
    		}
  		};
	};

	// 现在它可以运行了！
	for (let num of range) {
  		alert(num); // 1, 然后是 2, 3, 4, 5
	}
	</code></pre>
	<p>参考来源<a href="https://zh.javascript.info/iterable">JAVASCRIPT.INFO</a>使用Symbol.iteraor迭代示例</p>

	<h3>To Do List</h3>
	<ol>
		<li>丰富Funlibs函数库</li>
		<li>用CSS美化网页</li>
	</ol>
	<label>更新于<input type="date" value="2021-03-28" disabled>__chinrunja</label>
	<hr>

	<!-- 2021-03-29 updated -->

	<div class="fixed"><a class="index" href="#索引">回到索引</a></div>

	<h2 id="10. 遍历对象并修改值">10. 遍历对象并修改值</h2>
	<ol>
		<li>使用 Object.entries(obj) 从 obj 获取由键/值对组成的数组。</li>
		<li>对该数组使用数组方法，例如 map。</li>
		<li>对结果数组使用 Object.fromEntries(array) 方法，将结果转回成对象。</li>
	</ol>
	<pre><code class="language-javascript">
	let prices = {
  		banana: 1,
  		orange: 2,
  		meat: 4
	};

	// 方法1：转换为数组，之后使用 map 方法，然后通过 fromEntries 再转回到对象
	Object.fromEntries(Object.entries(prices).map(([key, value]) => [key, value * 2]));

	// 方法2：使用for...of,遍历Object.keys操作对象
	for (let key of Object.keys(prices)) {
    	prices[key] *= 2;
	}
	</code></pre>
	<p>方法1参考来源<a href="https://zh.javascript.info/keys-values-entries">JAVASCRIPT.INFO</a>的Object.keys，values，entries的转换对象示例</p>

	<h2 id="11. 许多天之前是哪个月几号？">11. 许多天之前是哪个月几号？</h2>
	<pre><code class="language-javascript">
	let date = new Date(2015, 0, 2);

	function getDateAgo(date, days) {
		let dateCopy = new Date(date);

		dateCopy.setDate(dateCopy.getDate() - days);
		return dateCopy.getDate();
	}

	console.log( getDateAgo(date, 1) ); // 1, (1 Jan 2015)
	console.log( getDateAgo(date, 2) ); // 31, (31 Dec 2014)
	console.log( getDateAgo(date, 365) ); // 2, (2 Jan 2014)
	</code></pre>
	<p>参考来源<a href="https://zh.javascript.info/date">JAVASCRIPT.INFO</a>的日期和时间任务</p>

	<h3>To Do List</h3>
	<ol>
		<li>丰富Funlibs函数库</li>
		<li>用CSS美化网页</li>
	</ol>
	<label>更新于<input type="date" value="2021-03-29" disabled>__chinrunja</label>
	<hr>

	<!-- 2021-03-30 updated -->

	<h2 id="12. 生成第n个斐波那契数的3种方法">12. 生成第n个斐波那契数的3种方法</h2>
	<pre><code class="language-javascript">
	// 方法1: 递归
	function fib(n) {
  		return n <= 1 ? n : fib(n - 1) + fib(n - 2);
	}

	console.log( fib(3) ); // 2
	console.log( fib(7) ); // 13
	// fib(77); // 超级慢！

	// 方法2: 遍历1
	function fib(n) {
  		let a = 1;
  		let b = 1;
  		for (let i = 3; i <= n; i++) {
    		let c = a + b;
    		a = b;
    		b = c;
  		}
  		return b;
	}

	console.log( fib(3) ); // 2
	console.log( fib(7) ); // 13
	console.log( fib(77) ); // 5527939700884757

	// 方法2: 遍历2
	function fib(n) {
  		let arr = [1, 1];

  		for (let i = 2; i < n; i++) {
  			arr.push(arr[i - 1] + arr[i - 2]);
  		}

		return arr[n - 1];  		
	}
	</code></pre>
	<p>参考来源<a href="https://zh.javascript.info/recursion">JAVASCRIPT.INFO</a>的递归和堆栈任务</p>

	<h2 id="13. 使用 spread 语法进行数组/对象的浅拷贝">13. 使用 spread 语法进行对象/数组的浅拷贝</h2>
	<pre><code class="language-javascript">
	// 拷贝数组
	let arr = [1, 2, 3];
	let arrCopy = [...arr]; // 将数组 spread 到参数列表中
                        	// 然后将结果放到一个新数组

	// 两个数组中的内容相同吗？
	console.log(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true

	// 两个数组相等吗？
	console.log(arr === arrCopy); // false（它们的引用是不同的）

	// 修改我们初始的数组不会修改副本：
	arr.push(4);
	console.log(arr); // 1, 2, 3, 4
	console.log(arrCopy); // 1, 2, 3

	// 拷贝对象
	let obj = { a: 1, b: 2, c: 3 };
	let objCopy = { ...obj }; // 将对象 spread 到参数列表中
                          	  // 然后将结果返回到一个新对象

	// 两个对象中的内容相同吗？
	console.log(JSON.stringify(obj) === JSON.stringify(objCopy)); // true

	// 两个对象相等吗？
	console.log(obj === objCopy); // false (not same reference)

	// 修改我们初始的对象不会修改副本：
	obj.d = 4;
	console.log(JSON.stringify(obj)); // {"a":1,"b":2,"c":3,"d":4}
	console.log(JSON.stringify(objCopy)); // {"a":1,"b":2,"c":3}
	</code></pre>
	<p>这种方式比使用 let arrCopy = Object.assign([], arr); 来复制数组，或使用 let objCopy = Object.assign({}, obj); 来复制对象写起来要短得多。</p>
	<p>参考来源<a href="https://zh.javascript.info/rest-parameters-spread">JAVASCRIPT.INFO</a>的Rest 参数与 Spread 语法示例</p>

	<h3>To Do List</h3>
	<ol>
		<li>丰富Funlibs函数库</li>
		<li>用CSS美化网页</li>
	</ol>
	<label>更新于<input type="date" value="2021-03-30" disabled>__chinrunja</label>
	<hr>

	<script src="../script/modules/prism.js" type="text/javascript"></script>
	<script type="text/javascript">
		// 输出num范围内的素数（质数）
		function showPrimes(num) {

			for (let i = 2; i < num; i++) {
				if ( isPrime(i) ) {
					console.log(i);
				}
			}

		}

		function isPrime(num) {
		    
			for (let j = 2; j < num; j++) {
				if (num % j === 0) {
					return false;
				}
			}

			return true;
		}

		// 判断对象是否为空
		function isEmpty(obj) {
			
			for (let key in obj) {
				return false;
			}

			return true;
		}

		// 递归返回正序范围内数组
		function rangeOfNumbers(startNum, endNum) {

			if (startNum === endNum) return [startNum];
			else if (startNum < endNum) {
				endNum--;
				return ( rangeOfNumbers(startNum, endNum) ).concat(endNum + 1);
			}
		}

		// 递归返回逆序范围内数组
		function rangeOfNumbers(startNum, endNum) {

			if (startNum === endNum) return [endNum];
			else if (startNum < endNum) {
				startNum++;
				return ( rangeOfNumbers(startNum, endNum) ).concat(startNum - 1);
			}
		}

		// 生成范围内随机数（包含起止点）
		function randomInteger(min, max) {
    		return Math.floor(Math.random() * (max - min + 1)) + min;
		}

		// 复杂度为O(n2)
		function getMaxSubSum(arr) {
  			let maxSum = 0;

  			for (let i = 0; i < arr.length; i++) {
    			let sumFixedStart = 0;
    			for (let j = i; j < arr.length; j++) {
      				sumFixedStart += arr[j];
      				maxSum = Math.max(maxSum, sumFixedStart);
    			}
  			}

  			return maxSum;
		}

		// 复杂度改进为O(n)
		function getMaxSubSum(arr) {
  			let maxSum = 0;
  			let partialSum = 0;

  			for (let item of arr) {
    			partialSum += item;
    			maxSum = Math.max(maxSum, partialSum);
    			if (partialSum < 0) partialSum = 0;
  			}

  			return maxSum;
		}

		// 随机排列数组。
		function shuffle(array) {
  			array.sort(() => Math.random() - 0.5);
		}

		let arr = [1, 2, 3];
		shuffle(arr);

		// 数组去重
		function unique(arr) {
			let uniqueArr = [];

			for (let item of arr) {
				if (!uniqueArr.includes(item)) {
					uniqueArr.push(item);
				}
			}

			return uniqueArr;
		}

		function unique(arr) {
    		return Array.from(new Set(arr));
		}

		// 迭代对象
		let range = {
  			from: 1,
  			to: 5
		};

		range[Symbol.iterator] = function() {

		  	return {
    			current: this.from,
    			last: this.to,

    			next() {
      				if (this.current <= this.last) {
        				return { done: false, value: this.current++ };
      				} else {
        				return { done: true };
      				}
    			}
  			};
		};

		for (let num of range) {
  			console.log(num);
		}

		// 方法1：转换为数组，之后使用 map 方法，然后通过 fromEntries 再转回到对象
		let prices = {
  			banana: 1,
  			orange: 2,
  			meat: 4
		};

		Object.fromEntries(Object.entries(prices).map(([key, value]) => [key, value * 2]));

		// 方法2：使用for...of,遍历Object.keys操作对象
		for (let key of Object.keys(prices)) {
    		prices[key] *= 2;
		}

		// N天前是几月几号？
		let date = new Date(2015, 0, 2);

		function getDateAgo(date, days) {
			let dateCopy = new Date(date);

			dateCopy.setDate(dateCopy.getDate() - days);
			return dateCopy.getDate();
		}

		console.log( getDateAgo(date, 1) ); // 1, (1 Jan 2015)
		console.log( getDateAgo(date, 2) ); // 31, (31 Dec 2014)
		console.log( getDateAgo(date, 365) ); // 2, (2 Jan 2014)

		// 2021-03-30 updated

		/*const backToIndex = document.getElementsByClassName("fixed")[0];

		window.addEventListener("mouseup", function() {
			backToIndex.hidden = true;
		});
		window.addEventListener("mousedown", function() {
			backToIndex.hidden = false;
		});*/

		// 方法1: 递归
		function fib(n) {
  			return n <= 1 ? n : fib(n - 1) + fib(n - 2);
		}

		console.log( fib(3) ); // 2
		console.log( fib(7) ); // 13
		// fib(77); // 超级慢！

		// 方法2: 遍历1
		function fib(n) {
  			let a = 1;
  			let b = 1;
  			for (let i = 3; i <= n; i++) {
    			let c = a + b;
    			a = b;
    			b = c;
  			}
  			return b;
		}

		console.log( fib(3) ); // 2
		console.log( fib(7) ); // 13
		console.log( fib(77) ); // 5527939700884757

		// 方法2: 遍历2
		function fib(n) {
  			let arr = [1, 1];

  			for (let i = 2; i < n; i++) {
  				arr.push(arr[i - 1] + arr[i - 2]);
  			}

			return arr[n - 1];  		
		}

		// 拷贝数组
		let arr1 = [1, 2, 3];
		let arrCopy = [...arr1];

		console.log(JSON.stringify(arr1) === JSON.stringify(arrCopy));
		console.log(arr1 === arrCopy);

		arr1.push(4);
		console.log(arr1); // 1, 2, 3, 4
		console.log(arrCopy); // 1, 2, 3

		// 拷贝对象
		let obj = { a: 1, b: 2, c: 3 };
		let objCopy = { ...obj }; 

		console.log(JSON.stringify(obj) === JSON.stringify(objCopy));
		console.log(obj === objCopy);

		obj.d = 4;
		console.log(JSON.stringify(obj)); // {"a":1,"b":2,"c":3,"d":4}
		console.log(JSON.stringify(objCopy)); // {"a":1,"b":2,"c":3}

	</script>
</body>
</html>