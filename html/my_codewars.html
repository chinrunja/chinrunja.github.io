<!DOCTYPE html>
<html lang="zh-CN">
<head>

	<title>My codewars</title>
	<link rel="stylesheet" type="text/css" href="../css/my_codewars.css">
	<link rel="stylesheet" type="text/css" href="../css/modules/prism.css">

</head>
<body>
	<!-- 2021/04/05 updated -->

	<h1>Codewars--JavaScript答题记录</h1>
	<hr>
	<h2 id="索引">索引</h2>
	<ul>
		<li><a href="#Day 01">Day 01</a></li>
		<li><a href="#Day 02">Day 02</a></li>
		<li><a href="#Day 03">Day 03</a></li>
		<li><a href="#Day 04">Day 04</a></li>
		<li><a href="#Day 05">Day 05</a></li>
		<li><a href="#Day 06">Day 06</a></li>
		<li><a href="#Day 07">Day 07</a></li>
		<li><a href="#Day 08">Day 08</a></li>
		
	</ul>
	<hr>

	<div class="fixed"><a class="index" href="#索引">回到索引</a></div>

	<h2 id="Day 01">Day 01</h2>
	<h3>第一题</h3>
	<p>Write a function, gooseFilter / goose-filter / goose_filter / GooseFilter, that takes an array of strings as an argument and returns a filtered array containing the same elements but with the 'geese' removed.
	The geese are any strings in the following array, which is pre-populated in your solution:</p>
	<pre><code class="language-javascript">
	geese = ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"]
	</code></pre>
	<p>For example, if this array were passed as an argument:</p>
	<pre><code class="language-javascript">
	["Mallard", "Hook Bill", "African", "Crested", "Pilgrim", "Toulouse", "Blue Swedish"]
	</code></pre>
	<p>Your function would return the following array:</p>
	<pre><code class="language-javascript">
	["Mallard", "Hook Bill", "Crested", "Blue Swedish"]
	</code></pre>
	<p>The elements in the returned array should be in the same order as in the initial array passed to your function, albeit with the 'geese' removed. Note that all of the strings will be in the same case as those provided, and some elements may be repeated.</p>
	<pre><code class="language-javascript">
	// 我的方案
	function gooseFilter (birds) {
  		var geese = ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"];
  		let arr = [];
  		for (let bird of birds) {
    		if (!geese.includes(bird)) arr.push(bird);
  		}
  		return arr;
	}

	// 高票方案
	function gooseFilter (birds) {
  		var geese = ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"];
  		return birds.filter(b => !geese.includes(b));
	}
	</code></pre>

	<h3>第二题</h3>
	<p>You probably know the "like" system from Facebook and other pages. People can "like" blog posts, pictures or other items. We want to create the text that should be displayed next to such an item.</p>
	<p>Implement a function likes :: [String] -> String, which must take in input array, containing the names of people who like an item. It must return the display text as shown in the examples:</p>
	<pre><code class="language-javascript">
	likes [] -- must be "no one likes this"
	likes ["Peter"] -- must be "Peter likes this"
	likes ["Jacob", "Alex"] -- must be "Jacob and Alex like this"
	likes ["Max", "John", "Mark"] -- must be "Max, John and Mark like this"
	likes ["Alex", "Jacob", "Mark", "Max"] -- must be "Alex, Jacob and 2 others like this"
	</code></pre>
	<p>For 4 or more names, the number in and 2 others simply increases.</p>
	<pre><code class="language-javascript">
	// 我的方案
	function likes(names) {
  
  		if (names[3]) {
    		return `${names[0]}, ${names[1]} and ${names.length - 2 } others like this`;
  		} else if (names[2]) {
    		return `${names[0]}, ${names[1]} and ${names[2]} like this`;
  		} else if (names[1]) {
    		return `${names[0]} and ${names[1]} like this`;
  		} else if (names[0]) {
    		return `${names[0]} likes this`;
  		} else return 'no one likes this';
  
	}

	// 高票方案
	function likes(names) {
  		names = names || [];
  		switch(names.length) {
    		case 0: return 'no one likes this'; break;
    		case 1: return names[0] + ' likes this'; break;
    		case 2: return names[0] + ' and ' + names[1] + ' like this'; break;
    		case 3: return names[0] + ', ' + names[1] + ' and ' + names[2] + ' like this'; break;
    		default: return names[0] + ', ' + names[1] + ' and ' + (names.length - 2) + ' others like this';
  		}
	}
	</code></pre>

	<h3>第三题</h3>
	<p>Trolls are attacking your comment section!</p>
	<p>A common way to deal with this situation is to remove all of the vowels from the trolls' comments, neutralizing the threat.</p>
	<p>Your task is to write a function that takes a string and return a new string with all vowels removed.</p>
	<p>For example, the string "This website is for losers LOL!" would become "Ths wbst s fr lsrs LL!".</p>
	<p>Note: for this kata y isn't considered a vowel.</p>
	<pre><code class="language-javascript">
	// 我的方案
	function disemvowel(str) {
  		let vowels = ['a','o','e','i','u'];
  		for (let i = 0; i < str.length; i++) {
    		if ( vowels.includes(str[i]) || vowels.includes(str[i].toLowerCase()) ) {
      			str = str.replace(str[i], '');
      			i--;
    		}
  		}
  		return str;
	}

	// 高票方案
	function disemvowel(str) {
  		return str.replace(/[aeiou]/gi, '');
	}
	</code></pre>
	<label>更新于 <em>timestamp: 1617628341567</em> __chinrunja</label>
	<hr>

	<!-- 2021/04/06 updated -->

	<h2 id="Day 02">Day 02</h2>
	<h3>第一题</h3>
	<p>Deoxyribonucleic acid (DNA) is a chemical found in the nucleus of cells and carries the "instructions" for the development and functioning of living organisms.</p>
	<p>In DNA strings, symbols "A" and "T" are complements of each other, as "C" and "G". You have function with one side of the DNA (string, except for Haskell); you need to get the other complementary side. DNA strand is never empty or there is no DNA at all (again, except for Haskell).</p>
	<pre><code class="language-javascript">
	DNAStrand ("ATTGC") // return "TAACG"

	DNAStrand ("GTAT") // return "CATA" 
	</code></pre>
	<pre><code class="language-javascript">
	// 我的方案
	function DNAStrand(dna){
  	//your code here
  		let dnaArr = dna.split("");
  		for (let i = 0; i < dnaArr.length; i++) {
    		switch (dna[i]) {
        		case "A": dnaArr.splice(i, 1, "T"); break;
        		case "T": dnaArr.splice(i, 1, "A"); break;
        		case "C": dnaArr.splice(i, 1, "G"); break;
        		case "G": dnaArr.splice(i, 1, "C"); break;
    		}
  		}
  		return dnaArr.join("");
	}

	// 高票方案
	function DNAStrand(dna) {
  		return dna.replace(/./g, function(c) {
    		return DNAStrand.pairs[c]
  		})
	}

	DNAStrand.pairs = {
  		A: 'T',
  		T: 'A',
  		C: 'G',
  		G: 'C',
	}
	</code></pre>

	<h3>第二题</h3>
	<p>In a small town the population is p0 = 1000 at the beginning of a year. The population regularly increases by 2 percent per year and moreover 50 new inhabitants per year come to live in the town. How many years does the town need to see its population greater or equal to p = 1200 inhabitants?</p>
	<pre><code class="language-javascript">
	At the end of the first year there will be: 
	1000 + 1000 * 0.02 + 50 => 1070 inhabitants

	At the end of the 2nd year there will be: 
	1070 + 1070 * 0.02 + 50 => 1141 inhabitants (** number of inhabitants is an integer **)

	At the end of the 3rd year there will be:
	1141 + 1141 * 0.02 + 50 => 1213

	It will need 3 entire years.
	</code></pre>
	<p>More generally given parameters:</p>
	<p>p0, percent, aug (inhabitants coming or leaving each year), p (population to surpass)</p>
	<p>the function nb_year should return n number of entire years needed to get a population greater or equal to p.</p>
	<p>aug is an integer, percent a positive or null floating number, p0 and p are positive integers (> 0)</p>
	<pre><code class="language-javascript">
	Examples:
	nb_year(1500, 5, 100, 5000) -> 15
	nb_year(1500000, 2.5, 10000, 2000000) -> 10
	</code></pre>
	<pre><code class="language-javascript">
	// 我的方案
	function nbYear(p0, percent, aug, p) {
  		let year = 0;
  
  		while (p0 < p) {
    		p0 = p0 + p0 * percent * 0.01 + aug;
    		year++;
  		}
  
  		return year;
	}

	// 高票方案
	function nbYear(p0, percent, aug, p) {
  		for(var y = 0; p0 < p; y++) p0 = p0 * (1 + percent / 100) + aug;
  		return y;
	}
	</code></pre>

	<h3>第三题</h3>
	<p>Take 2 strings s1 and s2 including only letters from a to z. Return a new sorted string, the longest possible, containing distinct letters - each taken only once - coming from s1 or s2.</p>
	<p>Examples:</p>
	<pre><code class="language-javascript">
	a = "xyaabbbccccdefww"
	b = "xxxxyyyyabklmopq"
	longest(a, b) -> "abcdefklmopqwxy"

	a = "abcdefghijklmnopqrstuvwxyz"
	longest(a, a) -> "abcdefghijklmnopqrstuvwxyz"
	</code></pre>
	<pre><code class="language-javascript">
	// 我的方案
	function longest(s1, s2) {
  		let set = new Set();
  
  		s1.split("").forEach((char) => set.add(char));
  		s2.split("").forEach((char) => set.add(char));
  
  		return Array.from(set).sort().join("");
	}

	// 高票方案
	const longest = (s1, s2) => [...new Set(s1+s2)].sort().join('');
	</code></pre>

	<label>更新于 <em>timestamp: 1617671408099</em> __chinrunja</label>
	<hr>

	<!-- 2021/04/07 updated -->

	<h2 id="Day 03">Day 03</h2>
	<h3>第一题</h3>
	<p>Digital root is the recursive sum of all the digits in a number.</p>
	<p>Given n, take the sum of the digits of n. If that value has more than one digit, continue reducing in this way until a single-digit number is produced. The input will be a non-negative integer.</p>
	<pre><code class="language-javascript">
	// Examples
	16  -->  1 + 6 = 7
   	942  -->  9 + 4 + 2 = 15  -->  1 + 5 = 6
	132189  -->  1 + 3 + 2 + 1 + 8 + 9 = 24  -->  2 + 4 = 6
	493193  -->  4 + 9 + 3 + 1 + 9 + 3 = 29  -->  2 + 9 = 11  -->  1 + 1 = 2

	// 我的方案
	function digital_root(n) {
  
  	function add(str) {
    	return str.split("").reduce((sum, num) => sum + +num, 0);
  	}
  
  	while (n > 9) {
    	n = add(String(n));
  	}
  
  		return n;
	}

	// 高票方案
	function digital_root(n) {
  		return (n - 1) % 9 + 1;
	}
	</code></pre>

	<h3>第二题</h3>
	<p>A pangram is a sentence that contains every single letter of the alphabet at least once. For example, the sentence "The quick brown fox jumps over the lazy dog" is a pangram, because it uses the letters A-Z at least once (case is irrelevant).</p>
	<p>Given a string, detect whether or not it is a pangram. Return True if it is, False if not. Ignore numbers and punctuation.</p>
	<pre><code class="language-javascript">
	// 我的方案
	function isPangram(string){
  
  		let alphabet = "abcdefghijklmnopqrstuvwxyz";
  		let i = 0;
  
  		for (let char of alphabet) {
      		if (!string.toLowerCase().includes(char)) {
          		return false;
      		} else {
          		i++;
          		if (i === 26) {
              		return true;
          		}
      		}
  		}     
	}

	// 高票方案
	function isPangram(string){
  		string = string.toLowerCase();
  		return "abcdefghijklmnopqrstuvwxyz".split("").every(function(x){
    		return string.indexOf(x) !== -1;
  		});
	}
	</code></pre>

	<h3>第三题</h3>
	<p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p>
	<p>Finish the solution so that it returns the sum of all the multiples of 3 or 5 below the number passed in.</p>
	<p>Note: If the number is a multiple of both 3 and 5, only count it once. Also, if a number is negative, return 0(for languages that do have them)</p>
	<pre><code class="language-javascript">
	// 我的方案
	function solution(number){
  		let set = new Set();
  		let n = Math.floor(number / 3);
  
  		for (let i = 1; i <= n; i++) {
    		if (i * 3 < number) {
      			set.add(i * 3);
    		}
    		if (i * 5 < number) {
      			set.add(i * 5);
    		}
  		}
  
  		return Array.from(set).reduce((sum, num) => sum + num, 0);
  
	}

	// 高票方案
	function solution(number){
  		var sum = 0;
  
  		for(var i = 1;i < number; i++){
    		if(i % 3 == 0 || i % 5 == 0){
      			sum += i
    		}
  		}
  		return sum;
	}
	</code></pre>

	<label>更新于 <em>timestamp: 1617758620467</em> __chinrunja</label>
	<hr>

	<!-- 2021/04/08 updated -->

	<h2 id="Day 04">Day 04</h2>
	<h3>第一题</h3>
	<p>Some numbers have funny properties. For example:</p>
	<p>89 --> 8¹ + 9² = 89 * 1</p>
	<p>695 --> 6² + 9³ + 5⁴= 1390 = 695 * 2</p>
	<p>46288 --> 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51</p>
	<p>Given a positive integer n written as abcd... (a, b, c, d... being digits) and a positive integer p</p>
	<p>we want to find a positive integer k, if it exists, such as the sum of the digits of n taken to the successive powers of p is equal to k * n.</p>
	<p>In other words:</p>
	<p>Is there an integer k such as : (a ^ p + b ^ (p+1) + c ^(p+2) + d ^ (p+3) + ...) = n * k</p>
	<p>If it is the case we will return k, if not return -1.</p>
	<p>Note: n and p will always be given as strictly positive integers.</p>
	<p>digPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1</p>
	<p>digPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k</p>
	<p>digPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2</p>
	<p>digPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51</p>
	<pre><code class="language-javascript">
	// 我的方案
	function digPow(n, p){
  
  		if (!(n > 0 && Math.trunc(n) == n) && (p > 0 && Math.trunc(p) == p)) return -1;
  
  		let num = n.toString(),
      		sum = 0;
  
  		for (let i = 0; i < num.length; i++) {
    		sum += (+num[i]) ** (p + i);
  		}
  
  		return sum % n == 0 ? sum / n : -1;
  
	}

	// 高票方案
	function digPow(n, p) {
  		var x = String(n).split("").reduce((s, d, i) => s + Math.pow(d, p + i), 0)
  		return x % n ? -1 : x / n
	}
	</code></pre>

	<h3>第二题</h3>
	<p>Write a function that takes in a string of one or more words, and returns the same string, but with all five or more letter words reversed (like the name of this kata).</p>
	<ul>
		<li>Strings passed in will consist of only letters and spaces.</li>
		<li>Spaces will be included only when more than one word is present.</li>
	</ul>
	<p>Examples:</p>
	<p>spinWords("Hey fellow warriors") => "Hey wollef sroirraw"</p>
	<p>spinWords("This is a test") => "This is a test"</p>
	<p>spinWords("This is another test") => "This is rehtona test"</p>
	<pre><code class="language-javascript">
	// 我的方案
	function spinWords(str) {
   		return str
          	   .split(" ")
          	   .map((x) => {
               		if (x.length >= 5) {
              			x = x.split("").reverse().join("");
            		}
            		return x
          		})
          	   .join(" ");
	}

	// 高票方案
	function spinWords(words) {
  		return words.split(' ').map(function (word) {
    		return (word.length > 4) ? word.split('').reverse().join('') : word;
  		}).join(' ');
	}
	</code></pre>

	<h3>第三题</h3>
	<p>ROT13 is a simple letter substitution cipher that replaces a letter with the letter 13 letters after it in the alphabet. ROT13 is an example of the Caesar cipher.</p>
	<p>Create a function that takes a string and returns the string ciphered with Rot13. If there are numbers or special characters included in the string, they should be returned as they are. Only letters from the latin/english alphabet should be shifted, like in the original Rot13 "implementation".</p>
	<pre><code class="language-javascript">
	// 我的方案
	function rot13(message){
  		let alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
  		let arr = alphabet.split("");
  
  		return message = message.split("").map((char) => {
    		if (arr.includes(char)) {
      			let index = arr.indexOf(char);
      			if ( index < 13 || (index > 25 && index < 39) ) return alphabet[index + 13];
      			else if ( (index > 12 && index < 26) || index > 38 ) return alphabet[index - 13];
    		} else return char;
  		}).join("");
	}

	// 高票方案
	function rot13(message) {
  		var a = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
  		var b = "nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM"
  		return message.replace(/[a-z]/gi, c => b[a.indexOf(c)])
	}
	</code></pre>

	<label>更新于 <em>timestamp: 1617848456248</em> __chinrunja</label>
	<hr>

	<!-- 2021/04/09 updated -->

	<h2 id="Day 05">Day 05</h2>
	<h3>第一题</h3>
	<p>A child is playing with a ball on the nth floor of a tall building. The height of this floor, h, is known.</p>
	<p>He drops the ball out of the window. The ball bounces (for example), to two-thirds of its height (a bounce of 0.66).</p>
	<p>His mother looks out of a window 1.5 meters from the ground.</p>
	<p>How many times will the mother see the ball pass in front of her window (including when it's falling and bouncing?</p>
	<p><strong>Three conditions must be met for a valid experiment:</strong></p>
	<ul>
		<li>Float parameter "h" in meters must be greater than 0</li>
		<li>Float parameter "bounce" must be greater than 0 and less than 1</li>
		<li>Float parameter "window" must be less than h.</li>
	</ul>
	<p>If all three conditions above are fulfilled, return a positive integer, otherwise return -1.</p>
	<p><strong>Note:</strong>The ball can only be seen if the height of the rebounding ball is strictly greater than the window parameter.</p>
	<pre><code class="language-javascript">
	// Examples:
	- h = 3, bounce = 0.66, window = 1.5, result is 3
	- h = 3, bounce = 1, window = 1.5, result is -1
	(Condition 2) not fulfilled).

	// 我的方案
	function bouncingBall(h,  bounce,  window) {
  
  		if ( h <= 0 || bounce >= 1 || bounce <= 0 || window >= h ) {
    		return -1;
  		} else {
    		let result = 1;
    		while (h * bounce > window) {
      			h = h * bounce;
      			result += 2;
    		}
    		return result;
  		}
	}

	// 高票方案
	function bouncingBall(h,  bounce,  window) {
  		var rebounds = -1;
  		if (bounce > 0 && bounce < 1) while (h > window) rebounds+=2, h *= bounce;
  		return rebounds;
	}
	</code></pre>

	<h3>第二题</h3>
	<p>The number 89 is the first integer with more than one digit that fulfills the property partially introduced in the title of this kata. What's the use of saying "Eureka"? Because this sum gives the same number.</p>
	<p>In effect: 89 = 8^1 + 9^2</p>
	<p>The next number in having this property is 135.</p>
	<p>See this property again: 135 = 1^1 + 3^2 + 5^3</p>
	<p>We need a function to collect these numbers, that may receive two integers a, b that defines the range [a, b] (inclusive) and outputs a list of the sorted numbers in the range that fulfills the property described above.</p>
	<p>Let's see some cases:</p>
	<p>sumDigPow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9]</p>
	<p>sumDigPow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89]</p>
	<p>If there are no numbers of this kind in the range [a, b] the function should output an empty list.</p>
	<p>sumDigPow(90, 100) == []</p>
	<p>Enjoy it!!</p>
	<pre><code class="language-javascript">
	// 我的方案
	function sumDigPow(a, b) {
    	let arr = [];
    
  		for (let i = a; i <= b; i++) {
        	let eureka = String(i).split("").reduce((sum, value, index) => sum + (+value) ** (index + 1), 0);
        	if (eureka === i) arr.push(i);
    	}
    
    	return arr;
	}

	// 高票方案
	function sumDigPow(a, b) {
  		var ans = [];
  		while(a <= b){
    		if(a.toString().split('').reduce((x,y,i)=>x + +y ** (i + 1),0) == a)
      		ans.push(a);
    		a++;
  		}
  		return ans;
	}
	</code></pre>

	<h3>第三题</h3>
	<p>For this exercise you will be strengthening your page-fu mastery. You will complete the PaginationHelper class, which is a utility class helpful for querying paging information related to an array.</p>
	<p>The class is designed to take in an array of values and an integer indicating how many items will be allowed per each page. The types of values contained within the collection/array are not relevant.</p>
	<p>The following are some examples of how this class is used:</p>
	<pre><code class="language-javascript">
	var helper = new PaginationHelper(['a','b','c','d','e','f'], 4);
	helper.pageCount(); //should == 2
	helper.itemCount(); //should == 6
	helper.pageItemCount(0); //should == 4
	helper.pageItemCount(1); // last page - should == 2
	helper.pageItemCount(2); // should == -1 since the page is invalid

	// pageIndex takes an item index and returns the page that it belongs on
	helper.pageIndex(5); //should == 1 (zero based index)
	helper.pageIndex(2); //should == 0
	helper.pageIndex(20); //should == -1
	helper.pageIndex(-10); //should == -1
	</code></pre>
	<pre><code class="language-javascript">
	// 我的方案
	function PaginationHelper(collection, itemsPerPage){
  		this.collection = collection;
  		this.itemsPerPage = itemsPerPage;
	}

	PaginationHelper.prototype.itemCount = function() {
  		return this.collection.length;
	}

	PaginationHelper.prototype.pageCount = function() {
  		return Math.ceil(this.collection.length / this.itemsPerPage);
	}

	PaginationHelper.prototype.pageItemCount = function(pageIndex) {
  		if (pageIndex >= this.pageCount() || pageIndex < 0) return -1;
  		else if ( pageIndex + 1 === this.pageCount() ) return this.collection.length % this.itemsPerPage;
  		else return this.itemsPerPage;
	}

	PaginationHelper.prototype.pageIndex = function(itemIndex) {
  		if (this.collection.length === 0 || itemIndex > this.collection.length || itemIndex < 0) return -1;
  		else return Math.trunc(itemIndex / this.itemsPerPage);
	}

	// 高票方案
	function PaginationHelper(collection, itemsPerPage){
  		this.collection = collection, this.itemsPerPage = itemsPerPage;
	}

	PaginationHelper.prototype.itemCount = function() {
  		return this.collection.length;
	}

	PaginationHelper.prototype.pageCount = function() {
  		return Math.ceil(this.collection.length / this.itemsPerPage);
	}

	PaginationHelper.prototype.pageItemCount = function(pageIndex) {
  		return pageIndex < this.pageCount() 
    	? Math.min(this.itemsPerPage, this.collection.length - pageIndex * this.itemsPerPage)
    	: -1;
	}

	PaginationHelper.prototype.pageIndex = function(itemIndex) {
  		return itemIndex < this.collection.length && itemIndex >= 0
    	? Math.floor(itemIndex / this.itemsPerPage)
    	: -1;
	}
	</code></pre>

	<label>更新于 <em>timestamp: 1617934734186</em> __chinrunja</label>
	<hr>

	
	<!-- 2021/04/10 updated -->

	<h2 id="Day 06">Day 06</h2>
	<h3>第一题</h3>
	<p>Write a function called sumIntervals/sum_intervals() that accepts an array of intervals, and returns the sum of all the interval lengths. Overlapping intervals should only be counted once.</p>
	<p><strong>Intervals</strong></p>
	<p>Intervals are represented by a pair of integers in the form of an array. The first value of the interval will always be less than the second value. Interval example: [1, 5] is an interval from 1 to 5. The length of this interval is 4.</p>
	<p><strong>Overlapping Intervals</strong></p>
	<p>List containing overlapping intervals:</p>
	<pre><code class="language-javascript">
	[
	  [1, 4],
	  [7, 10],
	  [3, 5]
	]
	</code></pre>
	<p>The sum of the lengths of these intervals is 7. Since [1, 4] and [3, 5] overlap, we can treat the interval as [1, 5], which has a length of 4.</p>
	<pre><code class="language-javascript">
	sumIntervals( [
   		[1,2],
   		[6, 10],
   		[11, 15]
	] ); // => 9

	sumIntervals( [
   		[1,4],
   		[7, 10],
   		[3, 5]
	] ); // => 7

	sumIntervals( [
   		[1,5],
   		[10, 20],
   		[1, 6],
   		[16, 19],
   		[5, 11]
	] ); // => 19
	</code></pre>
	<pre><code class="language-javascript">
	// 我的方案
	function sumIntervals(intervals){
  
  		let set = new Set();
    
    	intervals.forEach(arr => {
      		while (arr[0] < arr[1]) {
        		set.add(arr[0]);
          		arr[0]++;
      		}
    	});
    
    	return Array.from(set).length;
    	// return set.size;
	}

	// 高票方案
	function sumIntervals(intervals){
  		var numbers = [];
  		intervals.forEach( function(interval) {
    		for (var i = interval[0] ; i < interval[1] ; i++) {
      			if (numbers.indexOf(i) == -1) numbers.push(i);
    		}
  		});
  		return numbers.length;
	}
	</code></pre>

	<h3>第二题</h3>
	<p>1, 246, 2, 123, 3, 82, 6, 41 are the divisors of number 246. Squaring these divisors we get: 1, 60516, 4, 15129, 9, 6724, 36, 1681. The sum of these squares is 84100 which is 290 * 290.</p>
	<p><strong>Task</strong></p>
	<p>Find all integers between m and n (m and n integers such as 1 <= m <= n) such that the sum of their squared divisors is itself a square.</p>
	<p>We will return an array of subarrays or of tuples (in C an array of Pair) or a string. The subarrays (or tuples or Pairs) will have two elements: first the number the squared divisors of which is a square and then the sum of the squared divisors.</p>
	<p><strong>Example:</strong></p>
	<p>list_squared(1, 250) --> [[1, 1], [42, 2500], [246, 84100]]</p>
	<p>list_squared(42, 250) --> [[42, 2500], [246, 84100]]</p>
	<p>The form of the examples may change according to the language, see "Sample Tests".</p>
	<pre><code class="language-javascript">
	// 我的方案
	function listSquared(m, n) {
		let list = [];
    
    	while (m < n) {
        	let squaredSum,
            	squaredRoot,
        		arr = [];
        
        	for (let i = 1; i <= m; i++) {
            	if (m % i === 0) arr.push(i);
        	}
        
        	squaredSum = arr.map(value => value ** 2).reduce((sum, value) => sum + value, 0);
        	squaredRoot = Math.sqrt(squaredSum);
        
        	if (Math.trunc(squaredRoot) == squaredRoot) list.push([m, squaredSum]);
        	m++;
    	}
    
    	return list;
	}

	// 高票方案
	function listSquared (m, n) {
  		var matches = [];

  		for (var i = m; i <= n; ++i) {
    		var sum = getDivisors(i).reduce((sum, n) => sum + n * n, 0);
    		var ok = Number.isInteger(Math.sqrt(sum));

    		if (ok) {
      			matches.push([i, sum]);
    		}
  		}

  		return matches;
	}

	function getDivisors (n) {
  		var divisors = [];

  		for (var i = 1; i <= n / 2; ++i) {
    		if (n % i) {
      			continue;
    		}

    		divisors.push(i);
  		}

  		return divisors.concat([n]);
	}
	</code></pre>

	<h3>第三题</h3>
	<p>Given an array of integers, find the one that appears an odd number of times.</p>
	<p>There will always be only one integer that appears an odd number of times.</p>
	<pre><code class="language-javascript">
	findOdd([20,1,-1,2,-2,3,3,5,5,1,2,4,20,4,-1,-2,5]) --> 5;
  	findOdd([1,1,2,-2,5,2,4,4,-1,-2,5]) --> -1;
  	findOdd([20,1,1,2,2,3,3,5,5,4,20,4,5]) --> 5;
  	findOdd([10]) --> 10;
  	findOdd([1,1,1,1,1,1,10,1,1,1,1]) --> 10;
  	findOdd([5,4,3,2,1,5,4,3,2,10,10]) --> 1;
	// 我的方案
	function findOdd(A) {
		let Odd,
    		obj = {};
    
    	A.forEach(a => {
        	if (!obj[a]) obj[a] = 0;
        	obj[a]++;
    	});
    
    	let arr = Object.entries(obj);
    	arr.forEach(b => {
        	if (b[1] % 2 !== 0) Odd = b[0];
    	});
    
    	return +Odd;
	}

	// 高票方案
	function findOdd(A) {
  		var obj = {};
  		A.forEach(function(el){
    		obj[el] ? obj[el]++ : obj[el] = 1;
  		});
  
  		for(prop in obj) {
    		if(obj[prop] % 2 !== 0) return Number(prop);
  		}
	}
	</code></pre>

	<label>更新于 <em>timestamp: 1618024425559</em> __chinrunja</label>
	<hr>

	<!-- 2021/04/11 updated -->

	<h2 id="Day 07">Day 07</h2>
	<h3>第一题</h3>
	<p>My friend John and I are members of the "Fat to Fit Club (FFC)". John is worried because each month a list with the weights of members is published and each month he is the last on the list which means he is the heaviest.</p>
	<p>I am the one who establishes the list so I told him: "Don't worry any more, I will modify the order of the list". It was decided to attribute a "weight" to numbers. The weight of a number will be from now on the sum of its digits.</p>
	<p>For example 99 will have "weight" 18, 100 will have "weight" 1 so in the list 100 will come before 99.</p>
	<p>Given a string with the weights of FFC members in normal order can you give this string ordered by "weights" of these numbers?</p>
	<p><strong>Examples:</strong>"56 65 74 100 99 68 86 180 90" ordered by numbers weights becomes: </p>
	<p>"100 180 90 56 65 74 68 86 99"</p>
	<p>When two numbers have the same "weight", let us class them as if they were strings (alphabetical ordering) and not numbers:</p>
	<p>180 is before 90 since, having the same "weight" (9), it comes before as a string.</p>
	<p>All numbers in the list are positive numbers and the list can be empty.</p>
	<pre><code class="language-javascript">
	// 我的方案
	function orderWeight(strng) {
    
    	return strng.split(" ").sort((a, b) => {
        	function test(str) {
            	let sum = 0;
            
            	for (let n of str) {
                	sum += (+n);
            	}
            
            	return sum;
        	};

        	if (test(a) > test(b)) return 1;
        	else if (test(a) === test(b)) {
            return a > b ? 1 : -1;
        	} else return -1;
    	}).join(" ");
	}

	// 高票方案
	function orderWeight(strng) {
 		const sum = (str)=>str.split('').reduce((sum,el)=>(sum+(+el)),0);
  		function comp(a,b){
    		let sumA = sum(a);
    		let sumB = sum(b);
    		return sumA === sumB ? a.localeCompare(b) : sumA - sumB;
   		};
 		return strng.split(' ').sort(comp).join(' ');
	}
	</code></pre>

	<h3>第二题</h3>
	<p>What is an anagram? Well, two words are anagrams of each other if they both contain the same letters. For example:</p>
	<p>'abba' & 'baab' == true<br>
	'abba' & 'bbaa' == true<br>
	'abba' & 'abbba' == false<br>
	'abba' & 'abca' == false</p>
	<p>Write a function that will find all the anagrams of a word from a list. You will be given two inputs a word and an array with words. You should return an array of all the anagrams or an empty array if there are none. For example:</p>
	<p>anagrams('abba', ['aabb', 'abcd', 'bbaa', 'dada']) => ['aabb', 'bbaa']<br>
	anagrams('racer', ['crazer', 'carer', 'racar', 'caers', 'racer']) => ['carer', 'racer']<br>
	anagrams('laser', ['lazing', 'lazy',  'lacer']) => []<br>
	</p>
	<pre><code class="language-javascript">
	// 我的方案
	function anagrams(word, words) {
    	let len = word.length,
        	arr = [];
    
    	words = words.filter((w) => w.length == len);
    	word = word.split("").sort();
    	words.forEach((w, idx) => {
        	let count = 0;
        	w = w.split("").sort();
        	for (let i = 0; i < len; i++) {
            	if (w[i] == word[i]) count++;
        	}
        	if (count == len) arr.push(words[idx]);
    	});
    
    	return arr;
	}

	// 高票方案
	String.prototype.sort = function() {
  		return this.split("").sort().join("");
	};

	function anagrams(word, words) {
  		return words.filter(function(x) {
      		return x.sort() === word.sort();
  		});
	}
	</code></pre>

	<h3>第三题</h3>
	<p>Write a function, which takes a non-negative integer (seconds) as input and returns the time in a human-readable format (HH:MM:SS)</p>
	<ul>
		<li>HH = hours, padded to 2 digits, range: 00 - 99</li>
		<li>MM = minutes, padded to 2 digits, range: 00 - 59</li>
		<li>SS = seconds, padded to 2 digits, range: 00 - 59</li>
	</ul>
	<p>The maximum time never exceeds 359999 (99:59:59)</p>
	<pre><code class="language-javascript">
	// 我的方案
	function humanReadable(seconds) {
    	let hour = Math.trunc(seconds / 3600);
    	let minute = Math.trunc((seconds - hour * 3600) / 60);
    	let second = seconds % 60;
    
    	function format(num) {
        	return ('0' + num).slice(-2);
    	}
    
    	return `${format(hour)}:${format(minute)}:${format(second)}`;
	}

	// 高票方案
	function humanReadable(seconds) {
  		var pad = function(x) { return (x < 10) ? "0"+x : x; }
  		return pad(parseInt(seconds / (60*60))) + ":" +
         	   pad(parseInt(seconds / 60 % 60)) + ":" +
        	   pad(seconds % 60)
	}
	</code></pre>

	<label>更新于 <em>timestamp: 1618104752150</em> __chinrunja</label>
	<hr>

	<!-- 2021/04/12 updated -->

	<h2 id="Day 08">Day 08</h2>
	<h3>第一题</h3>
	<p>In this kata, you will write a function that returns the positions and the values of the "peaks" (or local maxima) of a numeric array.</p>
	<p>For example, the array arr = [0, 1, 2, 5, 1, 0] has a peak at position 3 with a value of 5 (since arr[3] equals 5).</p>
	<p>The output will be returned as an object with two properties: pos and peaks. Both of these properties should be arrays. If there is no peak in the given array, then the output should be {pos: [], peaks: []}.</p>
	<p>Example: pickPeaks([3, 2, 3, 6, 4, 1, 2, 3, 2, 1, 2, 3]) should return {pos: [3, 7], peaks: [6, 3]} (or equivalent in other languages)</p>
	<p>All input arrays will be valid integer arrays (although it could still be empty), so you won't need to validate the input.</p>
	<p>The first and last elements of the array will not be considered as peaks (in the context of a mathematical function, we don't know what is after and before and therefore, we don't know if it is a peak or not).</p>
	<p>Also, beware of plateaus !!! [1, 2, 2, 2, 1] has a peak while [1, 2, 2, 2, 3] and [1, 2, 2, 2, 2] do not. In case of a plateau-peak, please only return the position and value of the beginning of the plateau. For example: pickPeaks([1, 2, 2, 2, 1]) returns {pos: [1], peaks: [2]} (or equivalent in other languages)</p>
	<pre><code class="language-javascript">
	// 我的方案
	function pickPeaks(arr){
    	let obj = {pos: [], peaks: []};
    
    	function append(index) {
        	obj.pos.push(index);
        	obj.peaks.push(arr[index]);
    	}
    
  		arr.forEach((v, i, arr) => {
      		if (v < arr[i+1]) {
          		if (arr[i+1] > arr[i+2]) {
          			append(i+1);
          		}
          		if (arr[i+1] == arr[i+2]) {
                	let n = 3;
              		while (arr[i+1] == arr[i+n]) {
                    	n++;
                	}
                	if (arr[i+1] > arr[i+n]) {
                    	append(i+1);
                	}
          		}
      		}
 		});
  		return obj;
	}

	// 高票方案
	function pickPeaks(arr){
  		var result = {pos: [], peaks: []};
  		if(arr.length > 2) {
    		var pos = -1;
    		for(var i=1; i < arr.length; i++) {
      			if(arr[i] > arr[i-1]) {
        			pos = i;
      			} else if(arr[i] < arr[i-1] && pos != -1) {
        			result.pos.push(pos);
        			result.peaks.push(arr[pos]);
        			pos = -1;
      			}
    		}
  		}
  		return result;
	}
	</code></pre>

	<h3>第二题</h3>
	<p>Given the string representations of two integers, return the string representation of the sum of those integers.</p>
	<p>For example:</p>
	<p>sumStrings('1','2') // => '3'</p>
	<p>A string representation of an integer will contain no characters besides the ten numerals "0" to "9".</p>
	<pre><code class="language-javascript">
	// 我的方案
	function sumStrings(a,b) {
    	let result = [],
        	arrA = removeZero(a).split("").reverse(),
    		arrB = removeZero(b).split("").reverse();
    
    
    	function removeZero(str) {
        	if (!str) return '0';
        	for (let char of str) {
            	if (char == '0') str = str.slice(1);
            	else break;
        	}
        	return str;
    	}
        
    	function add(A, B) {
        	let lastCarry,
            	len = A.length;
        
        	A.reduce((carry, v, i) => {
        		let sum = +v + +B[i] + carry;
            	if (sum >= 10) {
                	carry = 1;
                	result.push(sum - 10);
            	} else {
            		result.push(sum);
            		carry = 0;
            	}
            	lastCarry = carry;
            	return carry;
    		}, 0);
        
        	if (lastCarry == 0) {
        		result = result.concat(B.slice(len));
        	} else {
            	if (A.length == B.length) {
            		result.push(1);
            	} else {
                	add([1], B.slice(len));
            	}
        	}
    	}

    	arrA.length > arrB.length ? add(arrB, arrA) : add(arrA, arrB);
    
    	return result.reverse().join("");
	}

	// 高票方案
	String.prototype.reverse = function() {
  		return this.split('').reverse().join('');
	}

	function sumStrings(a,b) {
  		a = a.reverse(); b = b.reverse();
  		var carry = 0;
  		var index = 0;
  		var sumDigits = [];
  		while (index < a.length || index < b.length || carry != 0) {
    		var aDigit = index < a.length ? parseInt(a[index]) : 0;
    		var bDigit = index < b.length ? parseInt(b[index]) : 0;
    		var digitSum = aDigit + bDigit + carry;
    		sumDigits.push((digitSum % 10).toString());
    		carry = Math.floor(digitSum / 10);
    		index++;
  		}
  		sumDigits.reverse();
  		while (sumDigits[0] == '0') sumDigits.shift();
  		return sumDigits.join('');
	}
	</code></pre>

	<label>更新于 <em>timestamp: 1618207212660</em> __chinrunja</label>
	<hr>

	<!-- 2021/xx/xx updated --更新模版

	<h2 id="Day xx">Day xx</h2>
	<h3>第一题</h3>
	<p></p>
	<pre><code class="language-javascript">
	// 我的方案
	// 高票方案
	</code></pre>

	<h3>第二题</h3>
	<p></p>
	<pre><code class="language-javascript">
	// 我的方案
	// 高票方案
	</code></pre>

	<h3>第三题</h3>
	<p></p>
	<pre><code class="language-javascript">
	// 我的方案
	// 高票方案
	</code></pre>

	<label>更新于 <em>timestamp: </em> __chinrunja</label>
	<hr>

	-->

	<script src="../script/modules/prism.js" type="text/javascript"></script>
	<script type="text/javascript">
	
	</script>
</body>
</html>